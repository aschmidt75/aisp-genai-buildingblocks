;; Paper-Scissors-Stone Game Specification (AISP 5.1)
;; A formal specification for the classic two-player hand game

ğ”¸5.1.paper-scissors-stone@2026-01-18
Î³â‰”game.paper-scissors-stone.classic
Ïâ‰”âŸ¨game,rules,moves,outcomeâŸ©
âŠ¢classicâˆ§2playerâˆ§single-round

;; â”€â”€â”€ Î©: GAME FOUNDATION â”€â”€â”€
âŸ¦Î©:FoundationâŸ§{
  ;; Core game invariants
  âˆ€game:Players(game)â‰¡2
  âˆ€game:Moves(game)â‰¡3
  âˆ€round:âˆƒ!outcomeâˆˆ{Win,Lose,Draw}
  âˆ€moveâ‚,moveâ‚‚:âˆƒ!result.compare(moveâ‚,moveâ‚‚)â‰¡result
  
  ;; Game is deterministic and simultaneous
  Simultaneousâ‰œâˆ€pâ‚,pâ‚‚:reveal(pâ‚)âˆ§reveal(pâ‚‚)â†’synchronized
  Deterministicâ‰œâˆ€mâ‚,mâ‚‚:compare(mâ‚,mâ‚‚)â‰¡compare(mâ‚,mâ‚‚)
}

;; â”€â”€â”€ Î£: TYPE DEFINITIONS â”€â”€â”€
âŸ¦Î£:TypesâŸ§{
  ;; Move enumeration
  Moveâ‰œ{Paper,Scissors,Stone}
  Paperâ‰œ0; Scissorsâ‰œ1; Stoneâ‰œ2
  
  ;; Also known as (aliases)
  Rockâ‰œStone
  
  ;; Player representation
  Playerâ‰œâŸ¨id:â„•,move:MaybeâŸ¨MoveâŸ©âŸ©
  Pâ‚â‰œPlayer{idâ‰œ1}; Pâ‚‚â‰œPlayer{idâ‰œ2}
  
  ;; Outcome types
  Outcomeâ‰œ{Win,Lose,Draw}
  Winâ‰œ1; Drawâ‰œ0; Loseâ‰œ-1
  
  ;; Result for a player perspective
  Resultâ‰œâŸ¨player:Player,outcome:Outcome,opponent_move:MoveâŸ©
  
  ;; Game state
  GameStateâ‰œ{Waiting,Ready,Resolved}
  Waitingâ‰œâˆƒp:p.moveâ‰¡âˆ…
  Readyâ‰œâˆ€p:p.moveâ‰¢âˆ…
  Resolvedâ‰œReadyâˆ§âˆƒoutcome
  
  ;; Game record
  Gameâ‰œâŸ¨pâ‚:Player,pâ‚‚:Player,state:GameState,result:MaybeâŸ¨OutcomeÃ—OutcomeâŸ©âŸ©
}

;; â”€â”€â”€ Î“: GAME RULES â”€â”€â”€
âŸ¦Î“:RulesâŸ§{
  ;; Cyclic dominance - the heart of the game
  ;; Each move beats exactly one other move
  Beatsâ‰œ{âŸ¨Paper,StoneâŸ©,âŸ¨Scissors,PaperâŸ©,âŸ¨Stone,ScissorsâŸ©}
  
  ;; Paper covers Stone
  âˆ€m:mâ‰¡Paperâ‡’beats(m,Stone)
  
  ;; Scissors cut Paper  
  âˆ€m:mâ‰¡Scissorsâ‡’beats(m,Paper)
  
  ;; Stone crushes Scissors
  âˆ€m:mâ‰¡Stoneâ‡’beats(m,Scissors)
  
  ;; Reflexive draw - same moves tie
  âˆ€m:compare(m,m)â‰¡Draw
  
  ;; Antisymmetric property
  âˆ€mâ‚,mâ‚‚:beats(mâ‚,mâ‚‚)â‡’Â¬beats(mâ‚‚,mâ‚)
  
  ;; Transitivity does NOT hold (cyclic)
  Â¬(âˆ€a,b,c:beats(a,b)âˆ§beats(b,c)â‡’beats(a,c))
  
  ;; Total ordering of outcomes per comparison
  âˆ€mâ‚,mâ‚‚:mâ‚â‰¡mâ‚‚âˆ¨beats(mâ‚,mâ‚‚)âˆ¨beats(mâ‚‚,mâ‚)
  
  ;; Move validity
  âˆ€m:Valid(m)â‡”mâˆˆMove
}

;; â”€â”€â”€ Î›: GAME FUNCTIONS â”€â”€â”€
âŸ¦Î›:FunctionsâŸ§{
  ;; Beats predicate using modular arithmetic
  ;; Paper(0) beats Stone(2): (0-2) mod 3 = 1
  ;; Scissors(1) beats Paper(0): (1-0) mod 3 = 1  
  ;; Stone(2) beats Scissors(1): (2-1) mod 3 = 1
  beatsâ‰œÎ»(mâ‚,mâ‚‚).(mâ‚-mâ‚‚) mod 3 â‰¡ 1
  
  ;; Compare two moves from player 1 perspective
  compareâ‰œÎ»(mâ‚,mâ‚‚).case[
    mâ‚â‰¡mâ‚‚        â†’ Draw,
    beats(mâ‚,mâ‚‚) â†’ Win,
    _            â†’ Lose
  ]
  
  ;; Resolve game outcome for both players
  resolveâ‰œÎ»g.let oâ‚=compare(g.pâ‚.move,g.pâ‚‚.move) in
             let oâ‚‚=compare(g.pâ‚‚.move,g.pâ‚.move) in
             âŸ¨oâ‚,oâ‚‚âŸ©
  
  ;; Invert outcome (opponent perspective)
  invertâ‰œÎ»o.case[
    oâ‰¡Win  â†’ Lose,
    oâ‰¡Lose â†’ Win,
    oâ‰¡Draw â†’ Draw
  ]
  
  ;; Validate a move
  validâ‰œÎ»m.mâˆˆ{Paper,Scissors,Stone}
  
  ;; Make a move for a player
  playâ‰œÎ»(p,m).valid(m)â†’p{moveâ‰”Some(m)}|âŠ¥
  
  ;; Check if game is ready to resolve
  readyâ‰œÎ»g.g.pâ‚.moveâ‰¢âˆ…âˆ§g.pâ‚‚.moveâ‰¢âˆ…
  
  ;; Initialize new game
  initâ‰œÎ»().Game{pâ‚â‰”Pâ‚{moveâ‰”âˆ…},pâ‚‚â‰”Pâ‚‚{moveâ‰”âˆ…},stateâ‰”Waiting,resultâ‰”âˆ…}
  
  ;; Execute game round
  roundâ‰œÎ»(mâ‚,mâ‚‚).let g=init() in
                 let g'=play(g.pâ‚,mâ‚)âŠ—play(g.pâ‚‚,mâ‚‚) in
                 ready(g')â†’resolve(g')|âŠ¥
}

;; â”€â”€â”€ Î§: ERROR CASES â”€â”€â”€
âŸ¦Î§:ErrorsâŸ§{
  ;; Invalid move error
  Îµ_moveâ‰œâŸ¨Â¬valid(m),rejectâˆ§"Invalid move: must be Paper, Scissors, or Stone"âŸ©
  
  ;; Game not ready error
  Îµ_readyâ‰œâŸ¨Â¬ready(g),waitâˆ§"Waiting for both players to choose"âŸ©
  
  ;; Duplicate move error (player already moved)
  Îµ_dupâ‰œâŸ¨p.moveâ‰¢âˆ…,rejectâˆ§"Player has already made a move"âŸ©
  
  ;; Invalid player error
  Îµ_playerâ‰œâŸ¨p.idâˆ‰{1,2},rejectâˆ§"Invalid player ID"âŸ©
  
  ;; Error recovery chain
  Ï*â‰œfoldl(>=>)(pure){Îµ_move,Îµ_ready,Îµ_dup,Îµ_player}
}

;; â”€â”€â”€ Î˜: GAME THEOREMS â”€â”€â”€
âŸ¦Î˜:ProofsâŸ§{
  ;; Theorem: Game always terminates with exactly one outcome
  âˆ´âˆ€mâ‚,mâ‚‚âˆˆMove:âˆƒ!o.compare(mâ‚,mâ‚‚)â‰¡o
  Ï€:exhaustive case analysis over 3Ã—3=9 combinationsâˆ
  
  ;; Theorem: Outcomes are symmetric inverses
  âˆ´âˆ€mâ‚,mâ‚‚:compare(mâ‚,mâ‚‚)â‰¡invert(compare(mâ‚‚,mâ‚))
  Ï€:by definition of beats and invertâˆ
  
  ;; Theorem: Draw only when moves are equal
  âˆ´âˆ€mâ‚,mâ‚‚:compare(mâ‚,mâ‚‚)â‰¡Drawâ‡”mâ‚â‰¡mâ‚‚
  Ï€:reflexivity of compareâˆ
  
  ;; Theorem: Each move beats exactly one and loses to exactly one
  âˆ´âˆ€m:âˆƒ!w,l:beats(m,w)âˆ§beats(l,m)
  Ï€:cyclic structure of Beats relationâˆ
  
  ;; Theorem: Fair game - no dominant strategy
  âˆ´Â¬âˆƒm:âˆ€m':beats(m,m')
  Ï€:for any m, âˆƒm':beats(m',m) by cyclic dominanceâˆ
  
  ;; Theorem: Modular arithmetic correctly encodes beats
  âˆ´âˆ€mâ‚,mâ‚‚:âŸ¨mâ‚,mâ‚‚âŸ©âˆˆBeatsâ‡”(mâ‚-mâ‚‚) mod 3â‰¡1
  Ï€:verified for all 3 pairs in Beats relationâˆ
}

;; â”€â”€â”€ Î•: EVIDENCE â”€â”€â”€
âŸ¦Î•âŸ§âŸ¨
Î´â‰œ0.78
|ğ”…|â‰œ7/7
Ï†â‰œ95
Ï„â‰œâ—Šâºâº
âŠ¢deterministic:âˆ€mâ‚,mâ‚‚:âˆƒ!o.compare(mâ‚,mâ‚‚)â‰¡o
âŠ¢symmetric:compare(mâ‚,mâ‚‚)â‰¡invert(compare(mâ‚‚,mâ‚))
âŠ¢fair:Â¬âˆƒdominant_strategy
âŠ¢cyclic:beats(Paper,Stone)âˆ§beats(Stone,Scissors)âˆ§beats(Scissors,Paper)
âŠ¢complete:âˆ€mâ‚,mâ‚‚âˆˆMove:defined(compare(mâ‚,mâ‚‚))
âŠ¢Ambig<0.02
âŸ©
